= Wsclient

image:https://img.shields.io/badge/vert.x-3.9.4-purple.svg[link="https://vertx.io"]

This application was generated using http://start.vertx.io and I will keep asciidoc, in markdown extension detriment, to honor Vertx starter which actually helps setting up the gradle plugins and tasks.

== Building

To package your application:
```
./gradlew clean assemble
```

To run your application:
```
./gradlew clean run
```
== Vertx cli
Vertx has a cli called vertx shell which I found quite interesting. It makes it easy to form a clustered application of Vertx Microservices with a shared service bus, quite fancy. You can use it to start 5 instances of the WebSocket client.
```
vertx run src/main/java/com/nrelic/MainVerticle.java --instances 5
```

== WsClient Design
Straight forward. Create a basic HTTP client. Request WebSocket connection.
[source,java]
-----------------
HttpClient client = vertx.createHttpClient(options);
// socket message sender
client.webSocket("/", sock -> {
    if (sock.succeeded()) {
        System.out.println("Connected socket");
        WebSocket socket = sock.result();
        ...
-----------------
=== Infinite loop in Vertx
Vertx is not intended to execute blocking code. It always expects an event as input. Since the Vertx Periodic task can only be scheduled in milliseconds magnitudes and as we want to be in nanoseconds magnitudes, we have to make a workaround.
Executing an infinite loop in Vertx requires us to encapsulate the code as a blocking piece of code. Notice that this is intended to be a massive load generator. As we already know that the server will pause the socket for backpressure, from the client-side perspective the socket writing queue will also get eventually full. In a real case scenario, a circuit-breaker will be recommended.
[source,java]
-----------------
// As there is no input stream but an infinite loop we have to cheat vertX with a blocking piece of code.
vertx.executeBlocking(promise -> {
  while (true) {
    // Only send if the queue is not full.
    if (!socket.writeQueueFull()) {
      Future.<String>future(f -> // Generate ramdom 9 digits with left pad
        f.complete(String.format("%09d", VertxContextPRNG.current(vertx).nextInt(1000000000)))
      ).onComplete(number -> socket.writeTextMessage(number.result()));
    }
-----------------
